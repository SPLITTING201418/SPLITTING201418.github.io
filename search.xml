<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Makefile语法</title>
      <link href="/2022/10/30/makefile-yong-fa/"/>
      <url>/2022/10/30/makefile-yong-fa/</url>
      
        <content type="html"><![CDATA[<h1 id="Makefile基本语法"><a href="#Makefile基本语法" class="headerlink" title="Makefile基本语法"></a>Makefile基本语法</h1><p>make 是一个解释 makefile 中指令的命令工具。</p><p>make 工具最主要也是最基本的功能：就是通过 makefile文件 来描述源程序之间的相互关系并自动维护编译工作。而 makefile文件 需要按照某种语法进行编写，文件中需要说明如何编译各个源文件，并连接生成可执行文件，并要求定义源文件之间的依赖关系。</p><blockquote><p>-f 指定使用的Makefile 文件</p></blockquote><blockquote><p>-j 指定几个线程编译</p></blockquote><h2 id="一-Makefile的底层规则"><a href="#一-Makefile的底层规则" class="headerlink" title="一.Makefile的底层规则"></a>一.Makefile的底层规则</h2><pre><code>targets：prerequisites    command    command    ......目标：依赖    命令    命令    ......</code></pre><p>由此可见Makefile 的三要素就是 目标 依赖 以及 命令</p><ul><li>1.target 也就是一个目标文件，需要由make工具创建的目标体（target）。可以是Object File，也可以是执行文件。还可以是一个标签（Label），对于标签这种特性，在后续的“伪目标”章节中会有叙述。</li><li>2.prerequisites 就是要生成那个target所需要的文件或是目标。即要创建的目标体所依赖的文件（dependency_file）。</li><li>3.command 也就是make需要执行的命令（任意的Shell命令）。即创建每个目标体时需要运行的命令（command）。</li></ul><p><em><strong>注意：Makefile中的命令 写在一行和写在两行是有区别的，可以理解为 每一行都是用一个sh环境执行的，执行完成后该shell环境立即关闭</strong></em></p><h2 id="二-Makefile-变量的引入以及使用"><a href="#二-Makefile-变量的引入以及使用" class="headerlink" title="二.Makefile 变量的引入以及使用"></a>二.Makefile 变量的引入以及使用</h2><pre><code>CC=gcc -Wallobj/st_work.o : sources/st_work.c    \$(CC) \$(HEAD) \$(SRC) \$(OBJ)</code></pre><ul><li><p>1.实际上变量只能存储字符串。</p><p>  定义：变量名 = “字符串”</p><p>  使用：$(变量名)</p><p>  赋值方式：</p><pre><code>  直接对变量本身进行操作       =    递归展开赋值，当对一个变量进行操作时，如果这个变量后后面有变化，这个变量不会马上赋值，会一直找到最后一次变量，再进行赋值。      :=    就地展开赋值，当对一个变量进行操作，直接使用这个变量当前的值，而不受后面任何变量。            在变量的基础上加上东西      +=    对某个变量的值，进行追加      ?=    如果变量没有初始化，则对其初始化</code></pre></li><li><p>2.变量可以嵌套<br>$($(x))</p></li><li><p>3.自动变量<br>所有自动变量，自己本身存在的特定的作用。</p><pre><code>  $*    不包含拓展名的目标文件名称。  $+    所有的依赖文件名称，但是可能出现同名的。  $^    所有的依赖文件名称，但是不会出现同名的。  $&lt;  第一个依赖文件的名称。  $@    目标文件的完整名称  $?    所有已经更新的依赖文件的名字。（比目标文件要新的依赖文件）</code></pre></li></ul><h2 id="三-函数使用"><a href="#三-函数使用" class="headerlink" title="三.函数使用"></a>三.函数使用</h2><p>函数调用后，函数的返回值可以当做变量来使用。</p><p>调用格式如下所示：  $((function) (arguments);)</p><pre><code>$（函数名 函数参数列表）        wildcard:文件名展开函数。将所有用户想要找到的文件名给得到（用户想要得到的文件名可以通过通配符）。        用法：$(wildcard 可变参数列表）                 返回值：已经找到的文件名列表，每个文件名都加上空格。        $(wildcard *.c)</code></pre><h2 id="四-伪指令"><a href="#四-伪指令" class="headerlink" title="四.伪指令"></a>四.伪指令</h2><p>all  跟  make+目标文件</p><p>all表示最终目标，后来的依赖文件就可以写可执行文件，不需要写指令。</p><p>如果在all后面的依赖文件没有出现clean，但是你写了clean。那么makefile是不会自动执行clean，只有当单独输入make clean时，才会独立执行clean执行指令。</p><p>在许多Makefile中都可以看到.PHONY:xxx之类的语句，其含义就是定义xxx为伪目标，当一个目标被声明为伪目标后，make在执行规则时不会去试图去查找隐含规则来创建它。</p><p>可近似的理解为编译可选项：等用户想操作的时候才执行，用户不操作，不会自动执行。</p><h2 id="五-语法规则"><a href="#五-语法规则" class="headerlink" title="五.语法规则"></a>五.语法规则</h2><p>条件表达式的语法为：</p><pre><code>(conditional-directive);(text-if-true);endif</code></pre><p>以及：</p><pre><code>(conditional-directive);(text-if-true);else(text-if-false);endif</code></pre><p>其中(conditional-directive);表示条件关键字 ifeq ifneq ifdef ifndef<br>ifeq ((arg1),(arg2))</p><h2 id="六-Makefile调用shell命令"><a href="#六-Makefile调用shell命令" class="headerlink" title="六.Makefile调用shell命令"></a>六.Makefile调用shell命令</h2><p>Makefile脚本中，是可以直接调用shell命令的，并且在执行make时，能看到执行的shell语句。</p><p>在shell命令前添加：‘@’ 符号, 则可以不显示命令本身而只显示结果。</p><p>在shell命令前添加: ‘-‘  符号，则运行该条shell命令失败时，不会中断Makefile脚本的后续执行。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>内核编译obj-m和obj-y</title>
      <link href="/2022/10/30/nei-he-bian-yi-obj-m-he-obj-y/"/>
      <url>/2022/10/30/nei-he-bian-yi-obj-m-he-obj-y/</url>
      
        <content type="html"><![CDATA[<h1 id="内核编译obj-m和obj-y"><a href="#内核编译obj-m和obj-y" class="headerlink" title="内核编译obj-m和obj-y"></a>内核编译obj-m和obj-y</h1><p>在内核编译时，主要涉及一下文件：</p><blockquote><p>kernel/arch/arm/configs/*.defconfig </p></blockquote><blockquote><p>kernel/driver/*/Makefile</p></blockquote><blockquote><p>kernel/driver/*/Kconfig</p></blockquote><p>在进行模块编译时，主要有两个选项，obj-m和obj-y，而与内核密切相关的是obj-y选项，下面简单总结一下两者之间的区别:</p><pre><code>obj-m  += test.oobj-y  += test.o</code></pre><p>其中:</p><p>obj-m表示把文件test.o作为”模块”进行编译，不会编译到内核，但是会生成一个独立的 “test.ko” 文件；</p><p>obj-y表示把test.o文件编译进内核;</p><p>编译进内核的某个程序，若想以模块的方式进行执行，查阅****.ko-Makefile.</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Can&#39;t use &#39;defined(@array)&#39; (Maybe you should just omit the defined()) at kerneltimeconst.pl line 373.</title>
      <link href="/2022/10/30/can-t-use-defined-array/"/>
      <url>/2022/10/30/can-t-use-defined-array/</url>
      
        <content type="html"><![CDATA[<h1 id="Can’t-use-‘defined-array-’-Maybe-you-should-just-omit-the-defined-at-kerneltimeconst-pl-line-373"><a href="#Can’t-use-‘defined-array-’-Maybe-you-should-just-omit-the-defined-at-kerneltimeconst-pl-line-373" class="headerlink" title="Can’t use ‘defined(@array)’ (Maybe you should just omit the defined()) at kerneltimeconst.pl line 373."></a>Can’t use ‘defined(@array)’ (Maybe you should just omit the defined()) at kerneltimeconst.pl line 373.</h1><p>在对linux中Uboot和内核编译，运行编译指令：make zImage 生成内核镜像文件时，发生编译内核报错：</p><pre><code>    CHK     include/linux/version.h    CHK     include/generated/utsrelease.hmake[1]: 'include/generated/mach-types.h' is up to date.    CALL    scripts/checksyscalls.sh    CHK     include/generated/compile.h    TIMEC   kernel/timeconst.hCan't use 'defined(@array)' (Maybe you should just omit the defined()?) at kernel/timeconst.pl line 373./home/liuxueneng/workCode/rk3066/kernel/kernel/Makefile:141: recipe for target 'kernel/timeconst.h' failedmake[1]: *** [kernel/timeconst.h] Error 255Makefile:973: recipe for target 'kernel' failedmake: *** [kernel] Error 2</code></pre><p>错误信息：</p><blockquote><p>Can’t use ‘defined(@array)’ (Maybe you should just omit the defined()?) at kernel/timeconst.pl line 373</p></blockquote><p>已经提示详细的错误信息在哪里了，并且给出了可能的解决方案，打开timeconst.ps看一下：</p><pre><code>372        @val = @{$canned_values{$hz}};                                        373         if (!defined(@val)) {                                                          374                 @val = compute_values($hz);                                   375         }                                                                     376         output($hz, @val);</code></pre><p>根据提示去掉373行的defined，如下：</p><pre><code>372        @val = @{$canned_values{$hz}};                                        373         if (!(@val)) {                                                          374                 @val = compute_values($hz);                                   375         }                                                                     376         output($hz, @val);</code></pre><p>查阅了一下更新，发现其中有一项是perl版本升级到了 v5.22.1，然后查了perl官方文档，发现官网因为一个bug，该版本将defined(@array)去掉了。可以直接使用数组判断非空。</p><p>参考<a href="https://www.cnblogs.com/tid-think/p/10929435.html%E3%80%82">https://www.cnblogs.com/tid-think/p/10929435.html。</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>内核打印printk</title>
      <link href="/2022/10/29/printk-nei-he-da-yin/"/>
      <url>/2022/10/29/printk-nei-he-da-yin/</url>
      
        <content type="html"><![CDATA[<h1 id="内核打印printk"><a href="#内核打印printk" class="headerlink" title="内核打印printk"></a>内核打印printk</h1><p> 学习linux驱动中的过程中使用到了printk函数，并涉及到了KERN_EMERG参数的使用。记录下printk内核打印。</p><h2 id="一-printk简介"><a href="#一-printk简介" class="headerlink" title="一.printk简介"></a>一.printk简介</h2><p> printk 在内核源码中用来记录日志信息的函数，只能在内核源码范围内使用，用法类似于 printf 函数。</p><p> printk 函数主要做两件事情： </p><ul><li>将信息记录到 log 中；</li><li>调用控制台驱动来将信息输出</li></ul><p>printk 将内核信息输出到内核信息缓冲区中，内核缓冲区在 kernel/printk/printk.c 中定义：</p><blockquote><p>static char __log_buf[__LOG_BUF_LEN] __aligned(LOG_ALIGN);</p></blockquote><p>内核信息缓冲区是一个环形缓冲区（Ring Buffer），因此，如果塞入的消息过多，则就会将之前的消息冲刷掉。</p><h2 id="二-消息级别"><a href="#二-消息级别" class="headerlink" title="二.消息级别"></a>二.消息级别</h2><p>Linux 内核共提供了八种不同的消息级别，分为级别 0~7。数值越大，表示级别越低，对应的消息越不重要。相应的宏定义在 include/linux/kern_levels.h 文件中。</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">#define KERN_SOH   "\001"      /* ASCII Start Of Header */#define KERN_SOH_ASCII '\001'#define KERN_EMERG      KERN_SOH "0"   /* system is unusable */#define KERN_ALERT      KERN_SOH "1"   /* action must be taken immediately */#define KERN_CRIT       KERN_SOH "2"   /* critical conditions */#define KERN_ERR        KERN_SOH "3"   /* error conditions */#define KERN_WARNING    KERN_SOH "4"   /* warning conditions */#define KERN_NOTICE     KERN_SOH "5"   /* normal but significant condition */#define KERN_INFO       KERN_SOH "6"   /* informational */#define KERN_DEBUG      KERN_SOH "7"   /* debug-level messages */<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>说明：</p><ul><li>KERN_EMERG 表示紧急事件，一般是系统崩溃之前提示的消息；</li><li>KERN_ALERT 表示必须立即采取行动的消息；</li><li>KERN_CRIT 表示临界状态，通常涉及严重的硬件或软件操作失败；</li><li>KERN_ERR 用于报告错误状态，设备驱动程序会经常使用该级别来报告来自硬件的问题；</li><li>KERN_WARNING 对可能出现问题的情况进行警告，这类情况通常不会对系统造成严重的问题；</li><li>KERN_NOTICE 表示有必要进行提示的正常情形，许多与安全相关的状况用这个级别进行汇报；</li><li>KERN_INFO 表示内核提示信息，很多驱动程序在启动的时候，用这个级别打印出它们找到的硬件信息；</li><li>KERN_DEBUG 用于调试信息。</li></ul><h2 id="三-内核-printk-文件"><a href="#三-内核-printk-文件" class="headerlink" title="三.内核 printk 文件"></a>三.内核 printk 文件</h2><p>通过 /proc/sys/kernel/printk 文件可以调节 printk 的输出等级，该文件有 4 个数字值。例如，在 Ubuntu 上的值如下：</p><pre><code>&amp; cat /proc/sys/kernel/printk        4    4    1    7</code></pre><p>其中第一个“4”表示内核打印函数printk的打印级别，只有级别比他高的信息才能在控制台上打印出来，既 0－3级别的信息。</p><p>分别对应控制台日志级别、默认的消息日志级别、最低的控制台日志级别和默认的控制台日志级别。四个数值的含义如下：</p><ul><li>1.控制台日志级别：优先级高于该值的消息将被打印至控制台；</li><li>2.默认的消息日志级别：将用该优先级来打印没有优先级的消息；</li><li>3.最低的控制台日志级别：控制台日志级别可被设置的最小值（最高优先级）；</li><li>4.默认的控制台日志级别：控制台日志级别的缺省值。</li></ul><p>这四个值在 kernel/printk/printk.c 中被定义，如下：</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">int console_printk[4] = {        CONSOLE_LOGLEVEL_DEFAULT,       /* console_loglevel */        MESSAGE_LOGLEVEL_DEFAULT,       /* default_message_loglevel */        CONSOLE_LOGLEVEL_MIN,           /* minimum_console_loglevel */        CONSOLE_LOGLEVEL_DEFAULT,       /* default_console_loglevel */};EXPORT_SYMBOL_GPL(console_printk);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="四-调整打印级别"><a href="#四-调整打印级别" class="headerlink" title="四.调整打印级别"></a>四.调整打印级别</h2><h3 id="①-在-menuconfig-中修改"><a href="#①-在-menuconfig-中修改" class="headerlink" title="①.在 menuconfig 中修改"></a>①.在 menuconfig 中修改</h3><p>修改 CONFIG_MESSAGE_LOGLEVEL_DEFAULT 的值，然后重新编译，更新内核。menuconfig 配置路径如下：</p><pre><code>Kernel hacking  ---&gt;printk and dmesg options  ---&gt;    (4) Default message log level (1-7)</code></pre><h3 id="②在系统中修改"><a href="#②在系统中修改" class="headerlink" title="②在系统中修改"></a>②在系统中修改</h3><p>在系统运行期间，可以通过修改 /proc/sys/kernel/printk 中的值来改变内核打印效果。例如，屏蔽掉所有的内核 printk 打印，只需要把第一个数值调到最小值1或者0。</p><pre><code>echo 1       4       1      7 &gt; /proc/sys/kernel/printk</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>最冤枉的关键字</title>
      <link href="/2022/10/24/zui-yuan-wang-de-guan-jian-zi-sizeof/"/>
      <url>/2022/10/24/zui-yuan-wang-de-guan-jian-zi-sizeof/</url>
      
        <content type="html"><![CDATA[<h1 id="关键字—-sizeof"><a href="#关键字—-sizeof" class="headerlink" title="关键字—-sizeof"></a>关键字—-sizeof</h1><p>sizeof 是关键字不是函数，其实就算不知道它是否为 32 个关键字之一时，我们也可以<br>借助编译器确定它的身份。看下面的例子思考：</p><p>int i=0；</p><p>A),sizeof(int)； B)，sizeof(i)； C)，sizeof i； D)，sizeof int；</p><p>毫无疑问，32 位系统下 A)，B)的值为 4。至于C)、D)看下面的代码：</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">#include&lt;stdio.h&gt; int main(){int i=0,a;a=sizeof i ;printf("%d",a);}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>其中用了sizeof i 这种看着平常不怎用的用法，但是结果运行发现输出结果为4。说明sizeof i不仅能用并且与sizeof（i）是相同的输出。此时思考，函数名后面没有括号行吗？由此得出 sizeof 绝非函数。</p><p>这个时候再看下段代码：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;stdio.h&gt;</span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">int</span> a<span class="token punctuation">;</span>a<span class="token operator">=</span><span class="token keyword">sizeof</span> <span class="token keyword">int</span> <span class="token punctuation">;</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>运行发现报错：</p><blockquote><p>511C:\Users\DELL\Desktop\学习\C\1.cpp[Error] expected primary-expression before ‘int’</p></blockquote><p>编译器怎么怎么提示出错呢？不是说 sizeof 是个关键字，其后面的括号<br>可以没有么？那你想想 sizeof int 表示什么啊？int 前面加一个关键字？类型扩展？明显不正确，我们可以在 int 前加 unsigned，const 等关键字但不能加 sizeof。<br>由此可以得出结论：</p><p><em><strong>sizeof 在计算变量所占空间大小时，括号可以省略，而计算类型(模子)大小时不能省略</strong></em></p><p>参考文献：《C 语言深度解剖》-陈正冲 编著</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>LinuxGDB调试工具</title>
      <link href="/2022/10/24/linuxgdb-diao-shi-gong-ju/"/>
      <url>/2022/10/24/linuxgdb-diao-shi-gong-ju/</url>
      
        <content type="html"><![CDATA[<h1 id="linuxGDB调试工具"><a href="#linuxGDB调试工具" class="headerlink" title="linuxGDB调试工具"></a>linuxGDB调试工具</h1><h2 id="一、GDB简介"><a href="#一、GDB简介" class="headerlink" title="一、GDB简介"></a>一、GDB简介</h2><p>在学习Linux编程过程中，一直缺少一个调试工具，GDB是一个Linux系统中常用的调试工具。在Linux系统下可以直接运行man gdb或者gdb-help命令查询gdb工具。</p><h2 id="二、GDB主要功能"><a href="#二、GDB主要功能" class="headerlink" title="二、GDB主要功能"></a>二、GDB主要功能</h2><h3 id="1-设置断点"><a href="#1-设置断点" class="headerlink" title="1.设置断点"></a>1.设置断点</h3><h3 id="2-显示变量的值"><a href="#2-显示变量的值" class="headerlink" title="2.显示变量的值"></a>2.显示变量的值</h3><h3 id="3-单步执行（调试工具大多都具备）"><a href="#3-单步执行（调试工具大多都具备）" class="headerlink" title="3.单步执行（调试工具大多都具备）"></a>3.单步执行（调试工具大多都具备）</h3><h3 id="4-运行时修改变量的值；GDB允许在调试状态下修改变量的值，此功能在测试程序特例的时候有莫大的作用"><a href="#4-运行时修改变量的值；GDB允许在调试状态下修改变量的值，此功能在测试程序特例的时候有莫大的作用" class="headerlink" title="4.运行时修改变量的值；GDB允许在调试状态下修改变量的值，此功能在测试程序特例的时候有莫大的作用"></a>4.运行时修改变量的值；GDB允许在调试状态下修改变量的值，此功能在测试程序特例的时候有莫大的作用</h3><h3 id="5-路径跟踪；GDB可以将代码的路径打印，方便用户跟踪代码"><a href="#5-路径跟踪；GDB可以将代码的路径打印，方便用户跟踪代码" class="headerlink" title="5.路径跟踪；GDB可以将代码的路径打印，方便用户跟踪代码"></a>5.路径跟踪；GDB可以将代码的路径打印，方便用户跟踪代码</h3><h3 id="6-线程切换；在调试多线程的时候，这种作用举足轻重"><a href="#6-线程切换；在调试多线程的时候，这种作用举足轻重" class="headerlink" title="6.线程切换；在调试多线程的时候，这种作用举足轻重"></a>6.线程切换；在调试多线程的时候，这种作用举足轻重</h3><h3 id="7-反汇编；GDB可以把写的代码但编译为汇编指令，这对理解函数操作有巨大的作用"><a href="#7-反汇编；GDB可以把写的代码但编译为汇编指令，这对理解函数操作有巨大的作用" class="headerlink" title="7.反汇编；GDB可以把写的代码但编译为汇编指令，这对理解函数操作有巨大的作用"></a>7.反汇编；GDB可以把写的代码但编译为汇编指令，这对理解函数操作有巨大的作用</h3><h2 id="三、GDB基本操作"><a href="#三、GDB基本操作" class="headerlink" title="三、GDB基本操作"></a>三、GDB基本操作</h2><h3 id="1-GDB加载程序"><a href="#1-GDB加载程序" class="headerlink" title="1.GDB加载程序"></a>1.GDB加载程序</h3><p>在linux系统中，要使用GDB调试程序，在编译程序的时候需要加入 “-g”选项（如果不加入使用GDB时则会显示缺少GDB选项）；例如：</p><blockquote><p>$gcc –g –o helloworld helloworld.c</p></blockquote><p>①命令格式：”gdb 要调试的文件全名”</p><blockquote><p>$gdb helloworld</p></blockquote><p>②或者先输入‘gdb’，然后使用”file 要调试的文件全名“</p><blockquote><p>(gdb) file test</p></blockquote><h3 id="2-断点"><a href="#2-断点" class="headerlink" title="2.断点"></a>2.断点</h3><p>设置断点的命令时break，简写为b。有3种设置方式：</p><ul><li>b 行号：程序停止在设定的行之前</li><li>b 函数名称：程序停止在设定的函数之前</li><li>b 行号或者函数 if条件：这是条件断点，如果条件为真，则程序在到达指定行或函数时停止。</li></ul><h4 id="①设置断点"><a href="#①设置断点" class="headerlink" title="①设置断点"></a>①设置断点</h4><p>如果程序由很多的文件构成，在设置断点时要指定文件名：</p><blockquote><p>(gdb) b man.c 10</p></blockquote><blockquote><p>(gdb) b subfunction.c 20</p></blockquote><p>要设置一个<strong>条件断点</strong>，可以利用b if 命令，在调试循环代码段时这样的设置比较有用，省略了大量的手动调试，例如，在一个循环函数中，在i=2时设置断点：</p><blockquote><p>(gdb) b 46 if i==2</p></blockquote><h4 id="②显示当前GDB的断点信息"><a href="#②显示当前GDB的断点信息" class="headerlink" title="②显示当前GDB的断点信息"></a>②显示当前GDB的断点信息</h4><p>使用info break命令显示当前断点的信息</p><blockquote><p>(gdb) info b</p></blockquote><pre><code>Num Type Disp Enb Address What1 breakpoint keep y 0x080484b1 in main at filestat.c:15breakpoint already hit 1 time</code></pre><h4 id="③删除指定的断点"><a href="#③删除指定的断点" class="headerlink" title="③删除指定的断点"></a>③删除指定的断点</h4><p>删除断点使用 delete b 断点编号 命令。下面的命令会删除第8个断点：</p><blockquote><p>(gdb) delete b 8</p></blockquote><h3 id="④禁止断点"><a href="#④禁止断点" class="headerlink" title="④禁止断点"></a>④禁止断点</h3><p>禁止断点使用 disable b 断点编号 命令。下面的命令会禁用第9个断点：</p><blockquote><p>(gdb) disable b 9</p></blockquote><h4 id="⑤允许断点"><a href="#⑤允许断点" class="headerlink" title="⑤允许断点"></a>⑤允许断点</h4><p>允许断点使用 enable b 断点编号 命令。下面的命令会禁用第9个断点：</p><blockquote><p>(gdb) enable b 9</p></blockquote><h4 id="⑥清除断点"><a href="#⑥清除断点" class="headerlink" title="⑥清除断点"></a>⑥清除断点</h4><p>一次性的清除某行处的所有断点使用命令 clean 行号。下面的命令会清除在源代码中第32行的所设置的断点：</p><blockquote><p>(gdb) clean 32</p></blockquote><h3 id="3-打印程序源代码"><a href="#3-打印程序源代码" class="headerlink" title="3.打印程序源代码"></a>3.打印程序源代码</h3><p>打印文件代码的命令时list，简写为l。</p><blockquote><p>(gdb) list line1, line2</p></blockquote><p>打印从line1到line2之间的代码，如果不输入参数，默认从当前行开始打印。<br>(gdb) l</p><pre><code>1    #include&lt;sys/stat.h&gt;2    #include&lt;sys/types.h&gt;3    #include&lt;unistd.h&gt;4    #include&lt;stdio.h&gt;5  6    int main(void)7    {8        struct stat st;9        10        if(-1==stat("test.txt",&amp;st))(gdb)11        {12            printf("get file status failure\n");13            return -1;14        }15        printf("此文件的大小：%d\n",st.st_size);16        printf("此文件的租后修改时间：%d\n",st.st_mtime);17        printf("此文件的节点：%d\n",st.st_ino);18        printf("此文件的保护模式：%d\n",st.st_mode);19    }</code></pre><h3 id="4-打印数据"><a href="#4-打印数据" class="headerlink" title="4. 打印数据"></a>4. 打印数据</h3><p>打印变量或者表达式的值可以使用print命令，简写为p。</p><blockquote><p>(gdb) print 变量名（或表达式）</p></blockquote><h3 id="5-设置监测点"><a href="#5-设置监测点" class="headerlink" title="5.设置监测点"></a>5.设置监测点</h3><p>display命令可以设置监测变量的值，当遇到断点时，会显示监测变量的值。</p><blockquote><p>(gdb) display i</p></blockquote><pre><code>i=1</code></pre><h3 id="6-单步调试"><a href="#6-单步调试" class="headerlink" title="6.单步调试"></a>6.单步调试</h3><p>单步跟踪：next 简写为n</p><p>进入函数体：step 简写为 s</p><p>退出已进入的函数：finish</p><blockquote><p>(gdb) n</p></blockquote><blockquote><p>(gdb) s</p></blockquote><blockquote><p>(gdb) finish</p></blockquote><h3 id="7-变量类型检测"><a href="#7-变量类型检测" class="headerlink" title="7.变量类型检测"></a>7.变量类型检测</h3><p>在调试过程中有需要查看变量类型的情况，需要使用命令whatis 和ptype等。</p><ul><li>whatis 变量名 ：查看变量的类型，只能查看变量的类型名称，不能得到类型的详细信息。<blockquote><p>(gdb) whatis st</p></blockquote><p>  type = struct stat</p></li><li>ptype 变量名：查看变量类型的详细信息。<blockquote><p>(gdb) ptype st</p></blockquote><p>  type = struct stat {<br>  __dev_t st_dev;<br>  short unsigned int __pad1;<br>  __ino_t st_ino;<br>  __mode_t st_mode;<br>  __nlink_t st_nlink;<br>  __uid_t st_uid;<br>  __gid_t st_gid;<br>  __dev_t st_rdev;<br>  short unsigned int __pad2;<br>  __off_t st_size;<br>  __blksize_t st_blksize;<br>  __blkcnt_t st_blocks;<br>  struct timespec st_atim;<br>  struct timespec st_mtim;<br>  struct timespec st_ctim;<br>  long unsigned int __unused4;<br>  long unsigned int __unused5;<br>  }</p></li></ul><h3 id="8-参数设置和显示"><a href="#8-参数设置和显示" class="headerlink" title="8.参数设置和显示"></a>8.参数设置和显示</h3><p>使用set args命令来设置发送给程序的参数；使用show args 命令显示其默认的参数</p><blockquote><p>(gdb) set args 1 2 3</p></blockquote><blockquote><p>(gdb) show args</p></blockquote><pre><code>Argument list to give program being debugged when it is started is "1 2 3".</code></pre><h3 id="9-调用路径"><a href="#9-调用路径" class="headerlink" title="9.调用路径"></a>9.调用路径</h3><p>backtrace命令可以打印函数的调用路径，提供前向跟踪功能，此命令对跟踪函数很有用处。Backtrace打印一个顺序列表，函数从最近到最远的调用过程，包含调用函数和其中的参数。简写为bt。</p><h3 id="10-信息info"><a href="#10-信息info" class="headerlink" title="10.信息info"></a>10.信息info</h3><p>Info命令可获得当前命令的信息，例如获得断点的情况，参数的设置情况等。</p><blockquote><p>(gdb) info frame //查看栈信息</p></blockquote><pre><code>Stack level 0, frame at 0xbffff760:eip = 0x80484c5 in main (filestat.c:16); saved eip 0xb7e88e46source language c.Arglist at 0xbffff758, args:Locals at 0xbffff758, Previous frame's sp is 0xbffff760Saved registers:ebp at 0xbffff758, eip at 0xbffff75c</code></pre><blockquote><p>(gdb) info locals //查看所有局部变量</p></blockquote><h3 id="11-多线程"><a href="#11-多线程" class="headerlink" title="11.多线程"></a>11.多线程</h3><p>多线程是现代程序中经常采用的编程方法，而多线程由于执行过程中的调度随机性，不好调试。多线程调试主要有两点：先获得线程的ID好，然后转到该线程进行调试。</p><ul><li><p>Info thread 命令列出当前进程中的线程号，其中最前面的为调试用的ID。</p></li><li><p>thread id 命令进入需要调试的线程。</p></li></ul><blockquote><p>(gdb) info thread</p></blockquote><pre><code>Id Target Id Frame* 1 process 7854 "filestat" main () at filestat.c:15</code></pre><h3 id="12-反汇编"><a href="#12-反汇编" class="headerlink" title="12.反汇编"></a>12.反汇编</h3><p>Disassamble命令打印指定处的汇编代码，例如printf的汇编代码如下：</p><blockquote><p>(gdb) disassemble printf</p></blockquote><pre><code>Dump of assembler code for function printf:0xb7ebbc80 &lt;+0&gt;:    push %ebp0xb7ebbc81 &lt;+1&gt;:    mov %esp,%ebp0xb7ebbc83 &lt;+3&gt;:    push %ebx0xb7ebbc84 &lt;+4&gt;:    call 0xb7f85bc60xb7ebbc89 &lt;+9&gt;:    add $0x11a36b,%ebx0xb7ebbc8f &lt;+15&gt;:    sub $0xc,%esp0xb7ebbc92 &lt;+18&gt;:    lea 0xc(%ebp),%eax0xb7ebbc95 &lt;+21&gt;:    mov %eax,0x8(%esp)0xb7ebbc99 &lt;+25&gt;:    mov 0x8(%ebp),%eax0xb7ebbc9c &lt;+28&gt;:    mov %eax,0x4(%esp)0xb7ebbca0 &lt;+32&gt;:    mov -0x7c(%ebx),%eax0xb7ebbca6 &lt;+38&gt;:    mov (%eax),%eax0xb7ebbca8 &lt;+40&gt;:    mov %eax,(%esp)0xb7ebbcab &lt;+43&gt;:    call 0xb7eb17e0 &lt;vfprintf&gt;0xb7ebbcb0 &lt;+48&gt;:    add $0xc,%esp0xb7ebbcb3 &lt;+51&gt;:    pop %ebx0xb7ebbcb4 &lt;+52&gt;:    pop %ebp0xb7ebbcb5 &lt;+53&gt;:    retEnd of assembler dump.</code></pre><h2 id="13-help帮助信息"><a href="#13-help帮助信息" class="headerlink" title="13. help帮助信息"></a>13. help帮助信息</h2><p>用法类似于man。例如想查看命令c的信息：</p><blockquote><p>(gdb) help c</p></blockquote><pre><code>Continue program being debugged, after signal or breakpoint.If proceeding from breakpoint, a number N may be used as an argument,which means to set the ignore count of that breakpoint to N - 1 (so thatthe breakpoint won't break until the Nth time it is reached).If non-stop mode is enabled, continue only the current thread,otherwise all the threads in the program are continued. Tocontinue all stopped threads in non-stop mode, use the -a option.Specifying -a and an ignore count simultaneously is an error.</code></pre><p>此文档是根据个人根据习惯对GDB常用指令做了一个诠释，参考文档如下：<br><a href="https://www.cnblogs.com/kooyun/p/5471807.html">https://www.cnblogs.com/kooyun/p/5471807.html</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>博客搭建过程中的错误及解决方式</title>
      <link href="/2022/10/06/bo-ke-da-jian-guo-cheng-zhong-de-yi-xie-cuo-wu-ji-jie-jue-fang-shi/"/>
      <url>/2022/10/06/bo-ke-da-jian-guo-cheng-zhong-de-yi-xie-cuo-wu-ji-jie-jue-fang-shi/</url>
      
        <content type="html"><![CDATA[<h1 id="博客搭建过程中的错误及解决方式"><a href="#博客搭建过程中的错误及解决方式" class="headerlink" title="博客搭建过程中的错误及解决方式"></a>博客搭建过程中的错误及解决方式</h1><p>我的个人博客选用的是hexo+giuhub搭建，主题选用的matery，哔哩哔哩和网上有具体教程搜就可以在此就不再赘述。这篇博客记录一下在博客搭建过程中存在的一些问题以及解决方案。</p><p>我的个人博客：<a href="https://splitting201418.github.io/">https://splitting201418.github.io/</a><br>hexo+github博客搭建：<a href="https://www.bilibili.com/video/BV1mU4y1j72n/?spm_id_from=333.999.0.0&amp;vd_source=4ceee0ab3ff85edd250392a7a7b78bab">https://www.bilibili.com/video/BV1mU4y1j72n/?spm_id_from=333.999.0.0&amp;vd_source=4ceee0ab3ff85edd250392a7a7b78bab</a><br>Matery主题链接：<a href="https://github.com/blinkfox/hexo-theme-matery">https://github.com/blinkfox/hexo-theme-matery</a></p><h2 id="一-SpawnFailed报错"><a href="#一-SpawnFailed报错" class="headerlink" title="一.SpawnFailed报错"></a>一.SpawnFailed报错</h2><p>在本地利用git终端与github利用 hexo d 命令将本地文件部署到github上时，报错SpawnFailed。</p><p>一般这样的大部分是本地配置文件没有更新，我查了一下首先用删除文件夹中的.deploy_git文件夹，然后在git终端后输入命令 git config –global core.autocrlf false。再依次输入命令 hexo clean、hexo g、hexo d（虽然我自己没成功）。</p><p>实践解决方案:</p><pre class="line-numbers language-none"><code class="language-none">git config --global user.email "2602434740@qq.com"#giuhub注册邮箱git config --global user.name "splitting201418"#github注册用户名<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>然后就可以正常进入SSHkey输入界面。</p><h2 id="二-Matery主题界面标题无法显示中文"><a href="#二-Matery主题界面标题无法显示中文" class="headerlink" title="二.Matery主题界面标题无法显示中文"></a>二.Matery主题界面标题无法显示中文</h2><p>Matery主题是自带中文解析的。即将本地hexo根目录下的_config.yml文件中language改为zh-CN。但是我更改之后发现主标题还是显示乱码。</p><p>解决方式：将_config.yml文件以UTF-8形式保存。<br><img src="https://img-blog.csdnimg.cn/a8be6a27a704447dae1effa2c9544166.png"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2022/10/04/hello-world/"/>
      <url>/2022/10/04/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo new <span class="token string">"My New Post"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo server<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo generate<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo deploy<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
